/**
 * Tentackle - a framework for java desktop applications
 * Copyright (C) 2001-2008 Harald Krake, harald@krake.de, +49 7722 9508-0
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

// $Id: DbPreferencesKey.java 477 2009-08-09 18:54:26Z harald $


package org.tentackle.db;

import javax.swing.ImageIcon;
import org.tentackle.db.rmi.DbPreferencesKeyRemoteDelegate;
import java.util.ArrayList;
import java.util.List;
import org.tentackle.plaf.PlafGlobal;
import org.tentackle.util.Compare;



// @> $mapfile
// # a preferences key/value pair
// #
// # CREATE UNIQUE INDEX prefkey_nodeid on prefkey(nodeid, pkey);
// # CREATE INDEX prefkey_tableserial on prefkey (tableserial);
//
// long    0      nodeId          nodeid          ID of the preferences node
// String  128    key             pkey            name of the key
// String  255    value           pvalue          value of the key
// long    0      tableSerial     tableserial     tableserial [NOMETHOD,NODECLARE]
// @<




/**
 * A preferences key/value pair stored in the database.
 *
 * @author harald
 */
public class DbPreferencesKey extends DbObject {
  
  private static final long serialVersionUID = 5733105489734329678L;
  
  /** database tablename **/
  public static final String TABLENAME = "prefkey";
  
  private static DbObjectClassVariables classVariables = 
    new DbObjectClassVariables(DbPreferencesKey.class, TABLENAME, "Preferences Key", "Preferences Keys");

  
  
  static {
    // register updater for syncObject between jvms
    ModificationThread.getThread().registerTable(newByClassWrapped(DbPreferencesKey.class).getTableName(), new ModificationThread.SerialRunnable() {
      public void run(Db db, long serial) {
        if (DbPreferences.isAutoSync()) {
          DbPreferences.expireKeys(db, serial);
        }
      }
    });
  }
  

  
  /**
   * if node is "new", the childs won't get a valid node id.
   * Instead they are linked to the node by an object reference.
   */
  private DbPreferencesNode lazyNode;
  
  
  

  /**
   * Creates a preferences key.
   * 
   * @param db the db connection
   */
  public DbPreferencesKey (Db db)    {
    super(db);
  }
  
  /**
   * Creates a preferences key (without db connection).
   */
  public DbPreferencesKey() {
    super();
  }
  
  
  @Override
  public String toString()  {
    return (lazyNode != null ? ("(node: " + lazyNode + ")") : ("nodeId=" + nodeId)) + ", key='" + key + "', value='" + value + "'";
  }

  
  @Override
  public ImageIcon getIcon() {
    return PlafGlobal.getIcon("preferences");
  }

  
  @Override
  public boolean isCountingModification(int modType) {
    return true;
  }
  
  
  @Override
  public boolean isTableSerialValid() {
    return true;
  }
  
  
  /**
   * sets the "lazy" parent, i.e. a new parent without an ID.
   * 
   * @param node the parent node, null if none.
   */ 
  public void setLazyNode(DbPreferencesNode node) {
    this.lazyNode = node; 
  }
  
  /**
   * @return the lazy parent, if any
   */
  public DbPreferencesNode getLazyNode()  {
    return lazyNode; 
  }

  
  /**
   * {@inheritDoc}
   * <p>
   * Overridden to set the parent id if lazy parent set and has no id
   */
  @Override
  public boolean prepareSetFields()  {
    if (nodeId == 0) {
      if (lazyNode != null) {
        nodeId = lazyNode.getId();
        if (nodeId == 0 && lazyNode.save()) {
          nodeId = lazyNode.getId();
        }
      }
      return nodeId != 0;
    }
    else  {
      return true;    // nothing to do
    }
  }


  @Override
  public boolean getFields(ResultSetWrapper rs)  {
    // @wurblet getFields DbGetFields $mapfile

    // Code generated by wurblet. Do not edit!//GEN-BEGIN:getFields

    if (columnsValid == false)  {
      if (!isGettingFieldCount() && (rs.getColumnOffset() > 0 || isPartial())) {
        // invoked within joined select the first time
        getFieldCount(); // get column indexes with offset 0
        if (columnsValid == false) {
          DbGlobal.errorHandler.severe(rs.getDb(), null, 
                "initial getFieldCount() failed in " + getTableName()); 
        }
      }
      else {
        COLUMN_NODEID = rs.findColumn(FIELD_NODEID);
        updateFieldCount(COLUMN_NODEID);
        COLUMN_KEY = rs.findColumn(FIELD_KEY);
        updateFieldCount(COLUMN_KEY);
        COLUMN_VALUE = rs.findColumn(FIELD_VALUE);
        updateFieldCount(COLUMN_VALUE);
        COLUMN_TABLESERIAL = rs.findColumn(FIELD_TABLESERIAL);
        updateFieldCount(COLUMN_TABLESERIAL);
        COLUMN_SERIAL = rs.findColumn(FIELD_SERIAL);
        updateFieldCount(COLUMN_SERIAL);
        COLUMN_ID = rs.findColumn(FIELD_ID);
        updateFieldCount(COLUMN_ID);
        columnsValid = true;
      }
    }

    if (rs.getRow() <= 0) {
      return false;   // no valid row
    }

    nodeId = rs.getLong(COLUMN_NODEID);
    key = rs.getString(COLUMN_KEY);
    value = rs.getString(COLUMN_VALUE);
    setTableSerial(rs.getLong(COLUMN_TABLESERIAL));
    setId(rs.getLong(COLUMN_ID));
    setSerial(rs.getLong(COLUMN_SERIAL));

    // End of wurblet generated code.//GEN-END:getFields

    return true;
  }


  @Override
  public int setFields(PreparedStatementWrapper st)	{
    // @wurblet setFields DbSetFields $mapfile

    // Code generated by wurblet. Do not edit!//GEN-BEGIN:setFields

    int ndx = 0;
    st.setLong(++ndx, nodeId); 
    st.setString(++ndx, key); 
    st.setString(++ndx, value); 
    st.setLong(++ndx, getTableSerial()); 
    st.setLong(++ndx, getId());
    st.setLong(++ndx, getSerial());

    // End of wurblet generated code.//GEN-END:setFields

    return ndx;
  }


  /**
   * Selects a preferences key by its ID.
   */
  @Override
  public DbPreferencesKey select (long id)  {
    return (DbPreferencesKey)super.select(id);
  }

  
  @Override
  public DbObjectClassVariables getDbObjectClassVariables() {
    return classVariables;
  }  
  

  @Override
  public int prepareInsertStatement ()  {
    // @wurblet insert DbInsert $mapfile

    // Code generated by wurblet. Do not edit!//GEN-BEGIN:insert

    int stmtId = getInsertStatementId();
    if (stmtId == 0 || alwaysPrepare()) {
      // prepare it
      stmtId = getDb().prepareStatement(
            "INSERT INTO " + getTableName()
            + " (" + FIELD_NODEID
            + ","  + FIELD_KEY
            + ","  + FIELD_VALUE
            + ","  + FIELD_TABLESERIAL
            + ","  + FIELD_ID
            + ","  + FIELD_SERIAL + ") VALUES (" +
            "?," +     
            "?," +     
            "?," +     
            "?," +     
            "?," +
            "?)");
      setInsertStatementId(stmtId);
    }

    // End of wurblet generated code.//GEN-END:insert
    
    return stmtId;
  }


  @Override
  public int prepareUpdateStatement () {
    // @wurblet update DbUpdate $mapfile

    // Code generated by wurblet. Do not edit!//GEN-BEGIN:update

    int stmtId = getUpdateStatementId();
    if (stmtId == 0 || alwaysPrepare())  {
      // prepare it
      stmtId = getDb().prepareStatement(
            "UPDATE " + getTableName() + " SET "
            +       FIELD_NODEID + "=?"
            + "," + FIELD_KEY + "=?"
            + "," + FIELD_VALUE + "=?"
            + "," + FIELD_TABLESERIAL + "=?"
            + "," + FIELD_SERIAL + "=" + FIELD_SERIAL + "+1"
            + " WHERE " + FIELD_ID + "=?"
            + " AND " + FIELD_SERIAL + "=?"
            );
      setUpdateStatementId(stmtId);
    }


    // End of wurblet generated code.//GEN-END:update
    
    return stmtId;
  }
  
  

  /**
   * Gets all keys belonging to a node.
   * 
   * @param nodeId the node's ID
   * @return List of keys
   *
   * @wurblet selectByNodeId DbSelectList $mapfile $remote nodeId
   */
  // Code generated by wurblet. Do not edit!//GEN-BEGIN:selectByNodeId

  public List<DbPreferencesKey> selectByNodeId(long nodeId) {
    if (getDb().isRemote())  {
      // invoke remote method
      try {
        List<DbPreferencesKey> list = ((DbPreferencesKeyRemoteDelegate)getRemoteDelegate()).selectByNodeId(nodeId);
        Db.applyToCollection(getDb(), list);
        return list;
      }
      catch (Exception e) {
        DbGlobal.errorHandler.severe(getDb(), e, "remote selectByNodeId failed");
        return null;
      }
    }
    // else: local mode
    int stmtId = selectByNodeIdStatementId;
    if (stmtId == 0 || alwaysPrepare()) {
      // prepare it
      stmtId = getDb().prepareStatement(getSqlSelectAllFields() 
                    + " AND " + FIELD_NODEID + "=?");
      selectByNodeIdStatementId = stmtId;
    }
    PreparedStatementWrapper st = getDb().getPreparedStatement(stmtId);
    int ndx = 1;
    st.setLong(ndx++, nodeId);
    ResultSetWrapper rs = st.executeQuery();
    List<DbPreferencesKey> list = new ArrayList<DbPreferencesKey>();
    boolean derived = getClass() != DbPreferencesKey.class;
    while (rs.next()) {
      DbPreferencesKey obj = derived ? (DbPreferencesKey)newObject() : new DbPreferencesKey(getDb());
      if (obj.readFromResultSetWrapper(rs))  {
        list.add(obj);
      }
    }
    rs.close();
    return list;
  }

  private static int selectByNodeIdStatementId;


  // End of wurblet generated code.//GEN-END:selectByNodeId



  
  /**
   * Get a preferences key by nodeid and key name.
   *
   * @param nodeId the node ID
   * @param key the key name
   * @return the preferences key, null if not found
   * 
   * @wurblet selectByNodeIdKey DbSelectUnique $mapfile $remote nodeId key
   */
  // Code generated by wurblet. Do not edit!//GEN-BEGIN:selectByNodeIdKey

  public DbPreferencesKey selectByNodeIdKey(long nodeId, String key) {
    if (getDb().isRemote())  {
      // invoke remote method
      try {
        DbPreferencesKey obj = ((DbPreferencesKeyRemoteDelegate)getRemoteDelegate()).selectByNodeIdKey(nodeId, key);
        Db.applyToDbObject(getDb(), obj);
        return obj;
      }
      catch (Exception e) {
        DbGlobal.errorHandler.severe(getDb(), e, "remote selectByNodeIdKey failed");
        return null;
      }
    }
    // else: local mode
    int stmtId = selectByNodeIdKeyStatementId;
    if (stmtId == 0 || alwaysPrepare())  {
      // prepare it
      stmtId = getDb().prepareStatement(getSqlSelectAllFields() 
                    + " AND " + FIELD_NODEID + "=?"
                    + " AND " + FIELD_KEY + "=?");
      selectByNodeIdKeyStatementId = stmtId;
    }
    PreparedStatementWrapper st = getDb().getPreparedStatement(stmtId);
    int ndx = 1;
    st.setLong(ndx++, nodeId);
    st.setString(ndx++, key);
    ResultSetWrapper rs = st.executeQuery();
    try {
      if (rs.next() && readFromResultSetWrapper(rs)) {
        return this;  // found
      }
      else {
        return null;  // not found
      }
    }
    finally {
      rs.close();
    }
  }

  private static int selectByNodeIdKeyStatementId;


  // End of wurblet generated code.//GEN-END:selectByNodeIdKey
  
  
  
  
  /**
   * Deletes all keys for a node.
   * 
   * @param nodeId the node's ID
   * @return the number of keys deleted
   *
   * @wurblet deleteByNodeId DbDeleteBy $mapfile $remote nodeId
   */
  // Code generated by wurblet. Do not edit!//GEN-BEGIN:deleteByNodeId

  public int deleteByNodeId(long nodeId) {
    if (getDb().isRemote())  {
      try {
        return ((DbPreferencesKeyRemoteDelegate)getRemoteDelegate()).deleteByNodeId(nodeId);
      }
      catch (Exception e) {
        DbGlobal.errorHandler.severe(getDb(), e, "remote deleteByNodeId failed");
        return 0;
      }
    }
    // else: local mode
    int stmtId = deleteByNodeIdStatementId;
    if (stmtId == 0 || alwaysPrepare()) {
      // prepare it
      stmtId = getDb().prepareStatement(
            "DELETE FROM " + getTableName() + " WHERE " +
            FIELD_NODEID + "=?");
      deleteByNodeIdStatementId = stmtId;
    }
    PreparedStatementWrapper st = getDb().getPreparedStatement(stmtId);
    st.setLong(1, nodeId);
    return st.executeUpdate();
  }

  private static int deleteByNodeIdStatementId;


  // End of wurblet generated code.//GEN-END:deleteByNodeId



  



  // @wurblet methods DbMethods --tracked $mapfile

  // Code generated by wurblet. Do not edit!//GEN-BEGIN:methods

  
  /**
   * Overridden cause of "--tracked".
   * @return true = setters check for modification
   */
  @Override
  public boolean isTracked() {
    return true;    // invoking isModified() is ok
  }

  /**
   * Gets the db attribute nodeId
   *
   * @return ID of the preferences node
   */
  public long getNodeId()    {
    return nodeId;
  }

  /**
   * Sets the db attribute nodeId
   *
   * @param nodeId ID of the preferences node
   */
  public void setNodeId(long nodeId) {
    if (!attributesModified()) {
      setModified(this.nodeId != nodeId);
    }
    this.nodeId = nodeId;
  }

  /**
   * Gets the db attribute key
   *
   * @return name of the key
   */
  public String getKey()    {
    return key;
  }

  /**
   * Sets the db attribute key
   *
   * @param key name of the key
   */
  public void setKey(String key) {
    if (!attributesModified()) {
      setModified(Compare.equals(this.key, key) == false);
    }
    this.key = key;
  }

  /**
   * Gets the db attribute value
   *
   * @return value of the key
   */
  public String getValue()    {
    return value;
  }

  /**
   * Sets the db attribute value
   *
   * @param value value of the key
   */
  public void setValue(String value) {
    if (!attributesModified()) {
      setModified(Compare.equals(this.value, value) == false);
    }
    this.value = value;
  }

  /**
   * no accessor methods for tableSerial
   * tableserial
   */

  // End of wurblet generated code.//GEN-END:methods



  // record members
  // @wurblet declare DbDeclare $mapfile

  // Code generated by wurblet. Do not edit!//GEN-BEGIN:declare


  /** ID of the preferences node **/
  private long nodeId;

  /** name of the key **/
  private String key;

  /** value of the key **/
  private String value;

  // End of wurblet generated code.//GEN-END:declare
  




  // @wurblet fieldNames DbFieldNames $mapfile

  // Code generated by wurblet. Do not edit!//GEN-BEGIN:fieldNames

  private static boolean columnsValid;    // true if COLUMN_.... are valid for getFields()
  /** database column name for nodeId **/
  public  static final String FIELD_NODEID = "nodeid";
  private static       int    COLUMN_NODEID;
  /** database column name for key **/
  public  static final String FIELD_KEY = "pkey";
  private static       int    COLUMN_KEY;
  /** database column name for value **/
  public  static final String FIELD_VALUE = "pvalue";
  private static       int    COLUMN_VALUE;
  private static       int    COLUMN_TABLESERIAL;
  private static       int    COLUMN_ID;
  private static       int    COLUMN_SERIAL;

  // End of wurblet generated code.//GEN-END:fieldNames

}


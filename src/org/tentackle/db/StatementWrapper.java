/**
 * Tentackle - a framework for java desktop applications
 * Copyright (C) 2001-2008 Harald Krake, harald@krake.de, +49 7722 9508-0
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

// $Id: StatementWrapper.java 466 2009-07-24 09:16:17Z svn $


package org.tentackle.db;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;



/**
 * A wrapper for sql statements.<br>
 * Will catch and report SQLExceptions and
 * keep track of being used only once after {@link Db#createStatement()}.
 *
 * @author harald
 */

public class StatementWrapper {
  
  
  /** the managed connection **/
  protected ManagedConnection con;
  /** the sql statement **/
  protected Statement stmt;  
  /** flag if statement is marked ready for being consumed **/
  protected boolean ready;
  
  
  /**
   * Creates a wrapper for an sql statement.
   *
   * @param con the connection
   * @param stmt the sql statement
   */
  public StatementWrapper (ManagedConnection con, Statement stmt) {
    this.con  = con;
    this.stmt = stmt;
  }
  
  
  /**
   * Gets the connection.
   *
   * @return the connection
   */
  public ManagedConnection getConnection() {
    return con;
  }
  

  /**
   * Gets the wrapped statement.
   * 
   * @return the statement, null if closed
   */
  public Statement getStatement ()  {
    return stmt;
  }
  
  
  /**
   * Gets the currently attached Db.
   *
   * @return the db
   */
  public Db getDb() {
    Db db = con.getDb();
    if (db == null) {
      throw new DbRuntimeException("illegal use of statement with detached connection " + con);
    }
    return db;
  }
  
  
  /**
   * Marks the statement to be ready for being consumed by a {@link Db} attached
   * to a {@link ConnectionManager}.<br>
   * This is an additional measure to enforce the programming rule that
   * a statement is being used only once after {@link Db#createStatement()} 
   * (for non-prepared statements) or after {@link Db#getPreparedStatement(int)}
   * for prepared statements.<p>
   * Notice: if a statement may be marked ready more than once, i.e. an open result
   * exists (which would be closed according to the JDBC specs), a DbRuntimeException is thrown.
   * The specs in {@link java.sql.Statement} say: 
   * <pre>
   * By default, only one ResultSet object per Statement object can be open at the same time. 
   * Therefore, if the reading of one ResultSet object is interleaved with the reading of another, 
   * each must have been generated by different Statement objects. 
   * All execution methods in the Statement interface implicitly close a statment's current 
   * ResultSet object if an open one exists.
   * </pre>
   * Without this additional measure a "ResultSet closed" exception will be thrown by the
   * JDBC-driver on the next usage of the first resultset and you wouldn't have any clue which
   * resultset forced the closing.
   */
  public void markReady() {
     if (isMarkedReady()) {
      throw new DbRuntimeException("statement " + this + " marked ready and not consumed yet");
    }
    ready = true;
  }
  
  /**
   * Unmarks (consumes) this statement previously marked ready.
   */
  public void unmarkReady() { 
    if (!isMarkedReady()) {
      throw new DbRuntimeException("statement " + this + " already consumed");
    }
    ready = false;
  }
  
  
  /**
   * Returns whether this statement is marked ready.<br>
   * Used to determine unused pending statements in servers when closing
   * dead sessions.
   * @return true if pending
   */
  public boolean isMarkedReady() {
    return ready;
  }
  
  
  /**
   * Returns the text representation of the wrapped statement.
   */
  @Override
  public String toString() {
    return '"' + stmt.toString() + '"';
  }
  
  
  /**
   * Detach the db from the connection.
   * Statements detach the db on executeUpdate or
   * on close() in the resultsetwrapper after executeQuery.
   */
  protected void detachDb() {
    con.getManager().detach(getDb().getConnectionId());
  }
  
  
  /**
   * Implementation of executeUpdate.
   * Overridden in PreparedStatementWrapper!
   * 
   * @param sql the sql string
   * @return the number of affected rows
   * @throws SQLException if update failes
   */
  int executeUpdateImpl(String sql) throws SQLException {
    unmarkReady(); // check for being marked ready and mark consumed
    getDb().setAlive(true);
    int count = stmt.executeUpdate(sql);
    if (count > 0) {
      getDb().addToUpdateCount(count);
    }
    detachDb();
    return count;
  }
  
  
  /**
   * Executes the given SQL statement.
   *
   * @param sql an sql-statement
   *
   * @return the row count
   */
  public int executeUpdate (String sql) {
    
    con.countForClearWarnings();
    getDb().setUniqueViolation(false);
    getDb().setAlive(true);
    
    if (DbGlobal.logger.isFinestLoggable()) {
      DbGlobal.logger.finest("execute statement " + stmt.toString() + (sql == null ? "" : (", sql='" + sql + "'")));
    }
    
    try {
      return executeUpdateImpl(sql);
    } 
    catch (SQLException e)  {
      // check for UNIQUE-violation, starts with "23" followed by vendor-specific codes
      String state = e.getSQLState();
      if (state != null && state.startsWith("23")) {
        getDb().setUniqueViolation(true);
        if (getDb().isUniqueViolationLogEnabled()) {
          DbGlobal.errorHandler.info(getDb(), e, Locales.bundle.getString("unique_violation_detected"));
        }
        // return 0 below
      }
      else  {
        // else: log severe error and terminate application
        DbGlobal.errorHandler.severe(getDb(), e, Locales.bundle.getString("Datenbankfehler_beim_Modifizieren_der_DB"));
        /**
         * due to the fact that sqlstates for "access violation" are mixed with syntax-error codes
         * we cannot detect such violations. Even worse, each DBMS got its own set of codes.
         * Postgres, for example, startswith 42. Others return 37, 2A or alike.
         * Hence, it doesn't make sense to check for an access violation in order to
         * give the user a more detailed error message. 
         */
      }
    }
    return 0;
  }
  
  
  
  /**
   * Implementation of executeQuery.
   * Overridden in PreparedStatementWrapper!
   */
  ResultSet executeQueryImpl(String sql) throws SQLException {
    getDb().setAlive(true);
    return stmt.executeQuery(sql);
  }
  
  

  /**
   * Executes a query.
   *
   * @param sql is the query sql string
   * @param withinTx is true if start a transaction for this query.
   *
   * @return the result set as a ResultSetWrapper
   */
  public ResultSetWrapper executeQuery (String sql, boolean withinTx) {
    
    con.countForClearWarnings();
    
    if (DbGlobal.logger.isFinestLoggable()) {
      DbGlobal.logger.finest("execute statement " + stmt.toString() + (sql == null ? "" : (", sql='" + sql + "'")));
    }
    
    try {
      if (withinTx) {
        withinTx = getDb().begin();  // returns true if autocommit on, i.e. we were not within a tx and begin() started a new one.
      }
      ResultSetWrapper rs = new ResultSetWrapper(this, executeQueryImpl(sql));
      if (withinTx) {
        rs.setCommitOnClose(true);  // commit tx on closing the resultset
      }
      return rs;
    } 
    catch (SQLException e)  {
      DbGlobal.errorHandler.severe(getDb(), e, Locales.bundle.getString("Datenbankfehler_beim_Abfragen_der_DB"));
    }
    return null;
  }
  
  
  /**
   * Executes a query.
   *
   * @param sql is the query sql string
   * @return the result set as a ResultSetWrapper
   */
  public ResultSetWrapper executeQuery (String sql) {
    return executeQuery(sql, false);
  }
  

  /**
   * Closes this statement.
   */
  public void close ()  {
    try {
      stmt.close();
      if (isMarkedReady()) {
        DbGlobal.logger.warning("statement " + this + " not consumed");
        ready = false;
      }
    } 
    catch (Exception e)  {
      DbGlobal.errorHandler.severe(getDb(), e, Locales.bundle.getString("Datenbankfehler_beim_Schliessen_des_SQL-PreparedStatements"));
    }
    finally {
      stmt = null;  // this marks it closed!
    }
  }
  
  
  /**
   * Determines whether this statement is closed.
   * 
   * @return true if statement closed
   */
  public boolean isClosed() {
    return stmt == null;
  }
  

  
  /**
   * Gives the JDBC driver a hint as to the number of rows that should 
   * be fetched from the database when more rows are needed for
   * <code>ResultSet</code> objects genrated by this <code>Statement</code>. 
   * If the value specified is zero, then the hint is ignored.
   * The default value is zero.
   *
   * @param rows the number of rows to fetch
   * @see #getFetchSize
   */
  public void setFetchSize(int rows)  {
    try {
      stmt.setFetchSize(rows);
    } 
    catch (SQLException e)  {
      DbGlobal.errorHandler.severe(getDb(), e, Locales.bundle.getString("setFetchSize_failed"));
    }    
  }

  
  /**
   * Retrieves the number of result set rows that is the default 
   * fetch size for <code>ResultSet</code> objects
   * generated from this <code>Statement</code> object.
   * If this <code>Statement</code> object has not set
   * a fetch size by calling the method <code>setFetchSize</code>,
   * the return value is implementation-specific.
   *
   * @return the default fetch size for result sets generated
   *          from this <code>Statement</code> object
   * @see #setFetchSize
   */
  public int getFetchSize() {
    try {
      return stmt.getFetchSize();
    } 
    catch (SQLException e)  {
      DbGlobal.errorHandler.severe(getDb(), e, Locales.bundle.getString("getFetchSize_failed"));
      return -1;    // not reached
    }       
  }
  
  
  /**
   * Sets the limit for the maximum number of rows that any
   * <code>ResultSet</code> object  generated by this <code>Statement</code>
   * object can contain to the given number.
   * If the limit is exceeded, the excess
   * rows are silently dropped.
   *
   * @param max the new max rows limit; zero means there is no limit 
   * @see #getMaxRows
   */
  public void setMaxRows(int max)  {
    try {
      stmt.setMaxRows(max);
    } 
    catch (SQLException e)  {
      DbGlobal.errorHandler.severe(getDb(), e, "setMaxRows failed");
    }    
  }
  
  
  /**
   * Retrieves the maximum number of rows that a
   * <code>ResultSet</code> object produced by this
   * <code>Statement</code> object can contain.  If this limit is exceeded, 
   * the excess rows are silently dropped.
   *
   * @return the current maximum number of rows for a <code>ResultSet</code>
   *         object produced by this <code>Statement</code> object; 
   *         zero means there is no limit
   * @see #setMaxRows
   */
  public int getMaxRows() {
    try {
      return stmt.getMaxRows();
    } 
    catch (SQLException e)  {
      DbGlobal.errorHandler.severe(getDb(), e, "getMaxRows failed");
      return -1;    // not reached
    }       
  }
  
  
  /**
   * Gives the driver a hint as to the direction in which
   * rows will be processed in <code>ResultSet</code>
   * objects created using this <code>Statement</code> object.  The 
   * default value is <code>ResultSet.FETCH_FORWARD</code>.
   * <P>
   * Note that this method sets the default fetch direction for 
   * result sets generated by this <code>Statement</code> object.
   * Each result set has its own methods for getting and setting
   * its own fetch direction.
   *
   * @param direction the initial direction for processing rows
   * @see #getFetchDirection
   */
  public void setFetchDirection(int direction) {
    try {
      stmt.setFetchDirection(direction);
    } 
    catch (SQLException e)  {
      DbGlobal.errorHandler.severe(getDb(), e, "db-error while rs.setFetchDirection()");
    }
  }
  
  
  /**
   * Retrieves the direction for fetching rows from
   * database tables that is the default for result sets
   * generated from this <code>Statement</code> object.
   * If this <code>Statement</code> object has not set
   * a fetch direction by calling the method <code>setFetchDirection</code>,
   * the return value is implementation-specific.
   *
   * @return the default fetch direction for result sets generated
   *          from this <code>Statement</code> object
   * @see #setFetchDirection
   */
  public int getFetchDirection() {
    try {
      return stmt.getFetchDirection();
    } 
    catch (SQLException e)  {
      DbGlobal.errorHandler.severe(getDb(), e, "db-error while rs.getFetchDirection()");
    }
    return ResultSet.FETCH_UNKNOWN;     // not reached  
  }
  

}
